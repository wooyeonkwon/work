#include <TFile.h>
#include <TTree.h>
#include <ROOT/RDataFrame.hxx>
#include <Math/Vector4D.h>
#include <DataFormats/MuonReco/interface/Muon.h>
#include <DataFormats/MuonReco/interface/MuonFwd.h>
#include <cmath>
#include <memory>
#include <iostream>

int classifyEta(double eta) {
    double abs_eta = std::abs(eta);
    if (abs_eta < 0.9) return 0;
    else if (abs_eta < 1.2) return 1;
    else if (abs_eta < 2.1) return 2;
    else if (abs_eta < 2.4) return 3;
    return -1;
}

int classifyPhi(double phi) {
    const double PI = M_PI;
    const double phiStep = 2 * PI / 10;
    double normalized_phi = phi;
    
    if (phi < -PI) normalized_phi += 2*PI;
    else if (phi > PI) normalized_phi -= 2*PI;
    
    int bin = static_cast<int>((normalized_phi + PI) / phiStep);
    return std::min(bin, 9);
}

struct MuonPair {
    reco::Muon muon1;
    reco::Muon muon2;
    bool valid;
    
    MuonPair() : valid(false) {}
    MuonPair(const reco::Muon& m1, const reco::Muon& m2) 
        : muon1(m1), muon2(m2), valid(true) {}
};

MuonPair findBestMuonPair(const std::vector<reco::Muon>& muons) {
    if (muons.size() < 2) return MuonPair();
    
    if (muons.size() == 2) {
        return MuonPair(muons[0], muons[1]);
    }
    
    double minMassDiff = std::numeric_limits<double>::max();
    size_t best_i = 0, best_j = 1;
    
    for (size_t i = 0; i < muons.size(); ++i) {
        for (size_t j = i + 1; j < muons.size(); ++j) {
            auto vec1 = muons[i].p4();
            auto vec2 = muons[j].p4();
            double mass = (vec1 + vec2).M();
            double massDiff = std::abs(mass - 91.2);
            
            if (massDiff < minMassDiff) {
                minMassDiff = massDiff;
                best_i = i;
                best_j = j;
            }
        }
    }
    
    return MuonPair(muons[best_i], muons[best_j]);
}

void analyzeMuons(const std::string& inputFile, const std::string& outputFile) {
    ROOT::EnableImplicitMT();  // Enable multi-threading
    
    // Create RDataFrame
    ROOT::RDataFrame df("Analysis/Analysis", inputFile);
    
    // Apply Z boson mass filter
    auto filtered_df = df.Filter([](const std::array<double, 6>& zBosonMass) {
        return zBosonMass[1] >= 60 && zBosonMass[1] <= 120;
    }, {"zBosonMass"}, "Z boson mass filter");
    
    // Create output file and tree
    TFile outFile(outputFile.c_str(), "RECREATE");
    TTree outTree("MuonAnalysis", "Analyzed Muon Data");
    
    // Define output variables
    int eventNumber, lumiSection, runNumber;
    double zBosonMass;
    double muon1_pt, muon1_eta, muon1_phi;
    int muon1_charge, muon1_eta_bin, muon1_phi_bin;
    double muon2_pt, muon2_eta, muon2_phi;
    int muon2_charge, muon2_eta_bin, muon2_phi_bin;
    
    // Set up branches
    outTree.Branch("eventNumber", &eventNumber);
    outTree.Branch("lumiSection", &lumiSection);
    outTree.Branch("runNumber", &runNumber);
    outTree.Branch("zBosonMass", &zBosonMass);
    outTree.Branch("muon1_pt", &muon1_pt);
    outTree.Branch("muon1_eta", &muon1_eta);
    outTree.Branch("muon1_phi", &muon1_phi);
    outTree.Branch("muon1_charge", &muon1_charge);
    outTree.Branch("muon1_eta_bin", &muon1_eta_bin);
    outTree.Branch("muon1_phi_bin", &muon1_phi_bin);
    outTree.Branch("muon2_pt", &muon2_pt);
    outTree.Branch("muon2_eta", &muon2_eta);
    outTree.Branch("muon2_phi", &muon2_phi);
    outTree.Branch("muon2_charge", &muon2_charge);
    outTree.Branch("muon2_eta_bin", &muon2_eta_bin);
    outTree.Branch("muon2_phi_bin", &muon2_phi_bin);
    
    // Process events
    filtered_df.Foreach([&](int evt, int lumi, int run, 
                          const std::array<double, 6>& zMass,
                          const std::vector<reco::Muon>& muons) {
        MuonPair bestPair = findBestMuonPair(muons);
        if (!bestPair.valid) return;
        
        // Fill event info
        eventNumber = evt;
        lumiSection = lumi;
        runNumber = run;
        zBosonMass = zMass[1];
        
        // Fill muon 1 info
        muon1_pt = bestPair.muon1.pt();
        muon1_eta = bestPair.muon1.eta();
        muon1_phi = bestPair.muon1.phi();
        muon1_charge = bestPair.muon1.charge();
        muon1_eta_bin = classifyEta(muon1_eta);
        muon1_phi_bin = classifyPhi(muon1_phi);
        
        // Fill muon 2 info
        muon2_pt = bestPair.muon2.pt();
        muon2_eta = bestPair.muon2.eta();
        muon2_phi = bestPair.muon2.phi();
        muon2_charge = bestPair.muon2.charge();
        muon2_eta_bin = classifyEta(muon2_eta);
        muon2_phi_bin = classifyPhi(muon2_phi);
        
        outTree.Fill();
    }, {"eventNumber", "lumiSection", "runNumber", "zBosonMass", "recoMuons"});
    
    // Write and close
    outTree.Write();
    outFile.Close();
}

int muonCor(int argc, char** argv) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " input_file.root output_file.root" << std::endl;
        return 1;
    }
    
    analyzeMuons(argv[1], argv[2]);
    return 0;
}